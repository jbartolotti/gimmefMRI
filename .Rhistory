modelname = 'BGR_g50_sg50'
mm
mm$model_spec
mm$model_spec[mm$model_spec$model_name == model_name,]
mm$model_spec[mm$model_spec$model_name == modelname,]
mm$model_spec[mm$model_spec$model_name == modelname,'network_name']
mm$lists
network_name <- mm$model_spec[mm$model_spec$model_name == modelname,'network_name']
mm$lists[network_name]
counts
head(counts)
empty_nodes <- data.frame(names(counts))
empty_nodes
empty_nodes <- counts[1,]
empty_nodes
empty_nodes[0,]
empty_nodes = counts[0,]
empty_nodes
empty_nodes$lhs <- nodes
nodes <- mm$lists[network_name]
empty_nodes$lhs <- nodes
rep(NA,4)
empty_nodes <- counts[0,]
for(n in nodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,rep(NA,dim(empty_nodes)[2]-1))}
dim(empty_nodes)
c(n,rep(NA,dim(empty_nodes)[2]-1))
nodes
nodes[[1]]
mm$lists[[network_name]]
nodes <- mm$lists[[network_name]]
for(n in nodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,rep(NA,dim(empty_nodes)[2]-1))}
empty_nodes
mm$shortnames
applyShorten(nodes,mm$shortnames)
counts
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,rep(NA,dim(empty_nodes)[2]-1))}
counts$lagged <- grepl('lag',counts$rhs)
shortnodes <- applyShorten(nodes,mm$shortnames)
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,rep(NA,dim(empty_nodes)[2]-1))}
counts$lagged <- grepl('lag',counts$rhs)
counts
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,rep(NA,dim(empty_nodes)[2]-1))}
counts <- rbind(counts,empty_nodes)
counts$lagged <- grepl('lag',counts$rhs)
counts
ccedge <- counts
if(SHOW_LAG){
}  else{ #remove rows where the predictor includes "lag"
ccedge <- subset(counts, !lagged)
}
if(SHOW_INDIVIDUAL){
} else{ #remove the column with individual counts
ccedge <- ccedge[,!(names(ccedge) %in% 'count.ind')]
}
if(SHOW_UNCONNECTED){
} else{ #remove rows where the sum of counts across columns is 0
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))]) #total connection count across groups/subgroups/individuals
ccedge <- ccedge[,totalConn != 0]
}
ccedge
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))],na.rm = TRUE) #total connection count across groups/subgroups/individuals
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))],na.rm = TRUE) #total connection count across groups/subgroups/individuals
ccedge[,grepl('count',names(ccedge))]
empty_nodes
grep('count',names(empty_nodes))
grepl('count',names(empty_nodes))
sum(grepl('count',names(empty_nodes)))
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,'~','NULL',rep(0,sum(grepl('count',names(empty_nodes)))))}
empty_nodes
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
cc2
devtools::load_all()
gimmefMRI_figures()
mm <- readModelInput(datadir, timecourse_file, model_spec_file, info_lists_file, shortnames_file)
network_name <- mm$model_spec[mm$model_spec$model_name == modelname,'network_name']
nodes <- mm$lists[[network_name]]
shortnodes <- applyShorten(nodes,mm$shortnames)
SHOW_LAG <- FALSE
SHOW_UNCONNECTED <- FALSE
SHOW_INDIVIDUAL <- TRUE
ALL_COLOR <- 'black'
INDIVIDUAL_COLOR <- 'grey'
SUBGROUP1_COLOR <- '#009900'
SUBGROUP2_COLOR <- '#00CCFF'
SHAPE = 'circle' #circle, square, triangle, diamond, heart
LAYOUT = 'circle' #circle, spring
#  estimates <- read.csv(file.path(modeldir,'indivPathEstimates.csv'), stringsAsFactors = FALSE)
#  estimates$group <- unlist(lapply(estimates$file,function(x){strsplit(x,'_')[[1]][1]}))
#  estimates$sub <- unlist(lapply(estimates$file,function(x){strsplit(x,'_')[[1]][2]}))
#  estimates$con <- paste(estimates$lhs,estimates$rhs, sep = '<-')
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,'~',n,rep(0,sum(grepl('count',names(empty_nodes)))))}
counts <- rbind(counts,empty_nodes)
counts$lagged <- grepl('lag',counts$rhs)
counts
ccedge <- counts
if(SHOW_LAG){
}  else{ #remove rows where the predictor includes "lag"
ccedge <- subset(counts, !lagged)
}
if(SHOW_INDIVIDUAL){
} else{ #remove the column with individual counts
ccedge <- ccedge[,!(names(ccedge) %in% 'count.ind')]
}
ccedge
if(SHOW_INDIVIDUAL){
} else{ #remove the column with individual counts
ccedge <- ccedge[,!(names(ccedge) %in% 'count.ind')]
}
ccedge[,!(names(ccedge) %in% 'count.ind')]
rowSums(ccedge[,grepl('count',names(ccedge))],na.rm = TRUE)
ccedge[,grepl('count',names(ccedge))]
devtools::load_all()
gimmefMRI_figures(
)
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))])
ccedge[,grepl('count',names(ccedge))]
rowSums(ccedge[,grepl('count',names(ccedge))])
summary(ccedge[,grepl('count',names(ccedge))])
grepl('count',colnames(counts))
counts[,grepl('count',colnames(counts))] <- as.numeric(ccedge[,grepl('count',names(ccedge))])
unlist(lapply(colnames(counts)[ccedge[,grepl('count',names(ccedge))]]),function(x){as.numeric(x)}))
unlist(lapply(colnames(counts)[ccedge[,grepl('count',names(ccedge))]]),function(x){as.numeric(x)})
unlist(lapply(colnames(counts)[ccedge[,grepl('count',names(ccedge))]],function(x){as.numeric(x)}))
unlist(lapply(colnames(counts)[ccedge[,grepl('count',names(ccedge))]],function(x){as.numeric(counts[,x])}))
colnames(counts)[ccedge[,grepl('count',names(ccedge))]]
colnames(counts)[grepl('count',names(ccedge))]
lapply(colnames(counts)[grepl('count',names(ccedge))], function(x){as.numeric(counts[,x])})
unlist(lapply(colnames(counts)[grepl('count',names(ccedge))], function(x){as.numeric(counts[,x])}))
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,'~',n,rep(0,sum(grepl('count',names(empty_nodes)))))}
counts <- rbind(counts,empty_nodes)
counts$lagged <- grepl('lag',counts$rhs)
for(col in grep('count',names(counts))){counts[,col] <- as.numeric(counts[,col])}
summary(counts)
devtools::load_all()
gimmefMRI_figures()
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))])
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,'~',n,rep(0,sum(grepl('count',names(empty_nodes)))))}
counts <- rbind(counts,empty_nodes)
counts$lagged <- grepl('lag',counts$rhs)
for(col in grep('count',names(counts))){counts[,col] <- as.numeric(counts[,col])}
ccedge <- counts
summary(ccedge)
if(SHOW_LAG){
}  else{ #remove rows where the predictor includes "lag"
ccedge <- subset(counts, !lagged)
}
summary(ccedge)
if(SHOW_INDIVIDUAL){
} else{ #remove the column with individual counts
ccedge <- ccedge[,!(names(ccedge) %in% 'count.ind')]
}
summary(ccedge)
totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))]) #total connection count across groups/subgroups/individuals
totalConn
ccedge[,totalConn != 0]
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
ccedge
cc2 = ccedge
cc2$weight = 0
cc2$color = ''
cc2$weight[cc2$count.ind > 0] = cc2$count.ind[cc2$count.ind > 0]
cc2$color[cc2$count.ind > 0] = 'grey'
cc2$weight[cc2$count.group > 0] = cc2$count.group[cc2$count.group > 0]
cc2$color[cc2$count.group > 0] = 'black'
cc2$weight[cc2$count.subgroup1 > 0] = cc2$count.subgroup1[cc2$count.subgroup1 > 0]
cc2$color[cc2$count.subgroup1 > 0] = 'blue'
cc2$weight[cc2$count.subgroup2 > 0] = cc2$count.subgroup2[cc2$count.subgroup2 > 0]
cc2$color[cc2$count.subgroup2 > 0] = 'green'
cc2
zeros(2,2)
rep(0,2,2)
matrix(0,2,3)
a <-matrix(0,2,3)
colnames(a) = c('a','b','c')
a
a[,'b']
all_nodes <- unique(c(unique(ccedge$lhs),unique(ccedge$rhs)))
all_nodes
matrix(0,4)
ccmat <- matrix(0,length(all_nodes),length(all_nodes))
ccmat
left_nodes <- unique(ccedge$lhs)
right_nodes <- unique(ccedge$rhs)
all_nodes <- unique(c(left_nodes,right_nodes))
ccmat <- matrix(0,length(all_nodes),length(all_nodes))
colnames(ccmat) <- all_nodes
rownames(ccmat) <- all_nodes
colormat <- matrix(0,length(all_nodes),length(all_nodes))
colnames(colormat) <- all_nodes
rownames(colormat) <- all_nodes
ccmat
ccedge$count.group[ccedge$lhs == 'LM1' & ccedge$rhs == 'dACC']
ccedge$count.group[ccedge$lhs == 'LM1' & ccedge$rhs == 'dACCeouoeu']
length(ccedge$count.group[ccedge$lhs == 'LM1' & ccedge$rhs == 'dACCeouoeu'])
counts <- read.table(file.path(modeldir,'summaryPathCounts.csv'), sep = ',', stringsAsFactors = FALSE, header = TRUE)
empty_nodes <- counts[0,]
for(n in shortnodes){empty_nodes[dim(empty_nodes)[1]+1,] = c(n,'~',n,rep(0,sum(grepl('count',names(empty_nodes)))))}
counts <- rbind(counts,empty_nodes)
counts$lagged <- grepl('lag',counts$rhs)
for(col in grep('count',names(counts))){counts[,col] <- as.numeric(counts[,col])}
ccedge <- counts
if(SHOW_LAG){
}  else{ #remove rows where the predictor includes "lag"
ccedge <- subset(counts, !lagged)
}
if(SHOW_INDIVIDUAL){
} else{ #remove the column with individual counts
ccedge <- ccedge[,!(names(ccedge) %in% 'count.ind')]
}
ccedge$totalConn <- rowSums(ccedge[,grepl('count',names(ccedge))]) #total connection count across groups/subgroups/individuals
if(SHOW_UNCONNECTED){
} else{ #remove rows where the sum of counts across columns is 0
ccedge <- ccedge[ccedge$totalConn != 0,]
}
left_nodes <- unique(ccedge$lhs)
right_nodes <- unique(ccedge$rhs)
all_nodes <- unique(c(left_nodes,right_nodes))
ccmat <- matrix(0,length(all_nodes),length(all_nodes))
colnames(ccmat) <- all_nodes
rownames(ccmat) <- all_nodes
colormat <- matrix('#000000',length(all_nodes),length(all_nodes))
colnames(colormat) <- all_nodes
rownames(colormat) <- all_nodes
for(left in left_nodes){
for(right in right_nodes){
thisconn <- ccedge$totalConn[ccedge$lhs == left & ccedge$rhs == right]
if(length(thisconn > 0 )) {ccmat[left,right] <- thisconn} else{ccmat[left,right] <- 0}
}
}
ccmat
thisconn <- ccedge[1,]
thisconn
'count.group' %in% colnames
'count.group' %in% colnames(thisconn)
left_nodes <- unique(ccedge$lhs)
right_nodes <- unique(ccedge$rhs)
all_nodes <- unique(c(left_nodes,right_nodes))
ccmat <- matrix(0,length(all_nodes),length(all_nodes))
colnames(ccmat) <- all_nodes
rownames(ccmat) <- all_nodes
colormat <- matrix('#000000',length(all_nodes),length(all_nodes))
colnames(colormat) <- all_nodes
rownames(colormat) <- all_nodes
for(left in left_nodes){
for(right in right_nodes){
thisconn <- ccedge[ccedge$lhs == left & ccedge$rhs == right,]
thiscolor <- '#000000'
thisweight <- 0
if('count.group' %in% colnames(thisconn) && thisconn$count.group > 0){
thiscolor <- ALL_COLOR
thisweight <- thisconn$count.group
}
if('count.subgroup1' %in% colnames(thisconn) && thisconn$count.subgroup1 > 0){
thiscolor <- SUBGROUP1_COLOR
thisweight <- thisconn$count.subgroup1
}
if('count.subgroup2' %in% colnames(thisconn) && thisconn$count.subgroup2 > 0){
thiscolor <- SUBGROUP2_COLOR
thisweight <- thisconn$count.subgroup2
}
if('count.ind' %in% colnames(thisconn) && thisconn$count.ind > 0){
thiscolor <- INDIVIDUAL_COLOR
thisweight <- thisconn$count.ind
}
ccmat[left,right] <- thisweight
colormat[left,right] <- thiscolor
}
}
thisconn
dim(thisconn)
all_nodes <- unique(c(left_nodes,right_nodes))
ccmat <- matrix(0,length(all_nodes),length(all_nodes))
colnames(ccmat) <- all_nodes
rownames(ccmat) <- all_nodes
colormat <- matrix('#000000',length(all_nodes),length(all_nodes))
colnames(colormat) <- all_nodes
rownames(colormat) <- all_nodes
for(left in left_nodes){
for(right in right_nodes){
thisconn <- ccedge[ccedge$lhs == left & ccedge$rhs == right,]
thiscolor <- '#000000'
thisweight <- 0
if(dim(thisconn)[1] > 0){
if('count.group' %in% colnames(thisconn) && thisconn$count.group > 0){
thiscolor <- ALL_COLOR
thisweight <- thisconn$count.group
}
if('count.subgroup1' %in% colnames(thisconn) && thisconn$count.subgroup1 > 0){
thiscolor <- SUBGROUP1_COLOR
thisweight <- thisconn$count.subgroup1
}
if('count.subgroup2' %in% colnames(thisconn) && thisconn$count.subgroup2 > 0){
thiscolor <- SUBGROUP2_COLOR
thisweight <- thisconn$count.subgroup2
}
if('count.ind' %in% colnames(thisconn) && thisconn$count.ind > 0){
thiscolor <- INDIVIDUAL_COLOR
thisweight <- thisconn$count.ind
}
}
ccmat[left,right] <- thisweight
colormat[left,right] <- thiscolor
}
}
ccmat
colormat
qgraph(ccmat)
qgraph(t(ccmat))
qgraph(cc2[,c('lhs','rhs','weight')],
layout = LAYOUT,
edge.color = cc2$color,
shape = SHAPE,
fade = FALSE
)
qgraph(t(ccmat),layout = 'circle',edge.color = t(colormat))
qgraph(cc2[,c('lhs','rhs','weight')],
layout = LAYOUT,
edge.color = cc2$color,
shape = SHAPE,
fade = FALSE
)
qgraph(ccmat,layout = 'circle',edge.color = colormat)
ccedge
for(left in left_nodes){
for(right in right_nodes){
thisconn <- ccedge[ccedge$lhs == left & ccedge$rhs == right,]
thiscolor <- '#000000'
thisweight <- 0
if(dim(thisconn)[1] > 0){
#individual first, so that it can get overwritten if needed. This occurs if a connection appears in one subgroup, and also in some individuals in the other subgroup.
if('count.ind' %in% colnames(thisconn) && thisconn$count.ind > 0){
thiscolor <- INDIVIDUAL_COLOR
thisweight <- thisconn$count.ind
}if('count.group' %in% colnames(thisconn) && thisconn$count.group > 0){
thiscolor <- ALL_COLOR
thisweight <- thisconn$count.group
}
if('count.subgroup1' %in% colnames(thisconn) && thisconn$count.subgroup1 > 0){
thiscolor <- SUBGROUP1_COLOR
thisweight <- thisconn$count.subgroup1
}
if('count.subgroup2' %in% colnames(thisconn) && thisconn$count.subgroup2 > 0){
thiscolor <- SUBGROUP2_COLOR
thisweight <- thisconn$count.subgroup2
}
}
ccmat[left,right] <- thisweight
colormat[left,right] <- thiscolor
}
}
qgraph(ccmat,layout = 'circle',edge.color = colormat)
for(left in left_nodes){
for(right in right_nodes){
thisconn <- ccedge[ccedge$lhs == left & ccedge$rhs == right,]
thiscolor <- '#000000'
thisweight <- 0
if(dim(thisconn)[1] > 0){
#individual first, so that it can get overwritten if needed. This occurs if a connection appears in one subgroup, and also in some individuals in the other subgroup.
if('count.ind' %in% colnames(thisconn) && thisconn$count.ind > 0){
thiscolor <- INDIVIDUAL_COLOR
thisweight <- thisconn$count.ind
}
if('count.group' %in% colnames(thisconn) && thisconn$count.group > 0){
thiscolor <- ALL_COLOR
thisweight <- thisconn$count.group
}
if('count.subgroup1' %in% colnames(thisconn) && thisconn$count.subgroup1 > 0){
thiscolor <- SUBGROUP1_COLOR
thisweight <- thisconn$count.subgroup1
}
if('count.subgroup2' %in% colnames(thisconn) && thisconn$count.subgroup2 > 0){
thiscolor <- SUBGROUP2_COLOR
thisweight <- thisconn$count.subgroup2
}
}
ccmat[left,right] <- thisweight
colormat[left,right] <- thiscolor
}
}
qgraph(ccmat,layout = 'circle',edge.color = colormat)
qgraph(ccmat,layout = 'circle',edge.color = colormat, fade = FALSE)
qgraph(cc2[,c('lhs','rhs','weight')],
layout = LAYOUT,
edge.color = cc2$color,
shape = SHAPE,
fade = FALSE
)
qgraph(ccmat,
layout = LAYOUT,
edge.color = colormat,
shape = SHAPE,
fade = FALSE
)
qgraph(cc2[,c('lhs','rhs','weight')],
layout = LAYOUT,
edge.color = cc2$color,
shape = SHAPE,
fade = FALSE
)
ccmat
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
all_nodes
rand(10)
randi(10)
randu(10)
shuffle(10)
runif(10)
runif(10,1,10)
sample(1:10)
sample(1:10,10)
sample(1:4)
sample(all_nodes)
test_order <- sample(all_nodes)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE
)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE,
curve = .5
)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE,
curve = 1
)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE,
curve = 1,
border.width = 2
)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE,
curve = 1,
border.width = 2,
border.color = 'red'
)
qgraph(ccmat[test_order,test_order],
layout = LAYOUT,
edge.color = colormat[test_order,test_order],
shape = SHAPE,
fade = FALSE,
curve = 1,
border.width = 2,
border.color = 'red',
asize = 6
)
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
all_nodes
all_nodes[node_order]
node_order <- sample(all_nodes)
all_nodes[node_order]
node_order
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
devtools::load_all()
gimmefMRI_figures()
gimmefMRI_figures()
dev.off()
devtools::load_all()
gimmefMRI()
library(readxl)
file.choose()
